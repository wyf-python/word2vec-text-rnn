import re


def detokenize_num(text):
    tokens = text.split()
    symbol = ['.', ',', '，', '/']
    for index, token in enumerate(tokens):
        if (index + 1 < len(tokens)) and token.isdigit() and tokens[index + 1].isdigit():
            # 1 000  ==> 1000
            tokens[index] = token + tokens[index + 1]
            del tokens[index + 1]
        elif (index + 2 < len(tokens)) and token.isdigit() and tokens[index + 1] in symbol and tokens[
            index + 2].isdigit():
            # 2 , 300、2 ， 300、2 . 300、2 / 300  ==> 2,300、2，300、2.300、2/300
            tokens[index] = token + tokens[index + 1] + tokens[index + 2]
            del tokens[index + 1]
            del tokens[index + 1]
        elif (index + 1 < len(tokens)) and token.isdigit() and tokens[index + 1][0] in symbol and tokens[index + 1][
                                                                                                  1:].isdigit():
            # 2 ,300、2 ，300、2 .300、2 /300  ==> 2,300、2，300、2.300、2/300
            tokens[index] = token + tokens[index + 1]
            del tokens[index + 1]
        elif (index + 1 < len(tokens)) and token[-1] in symbol and token[:-1].isdigit() and tokens[index + 1].isdigit():
            # 2, 300、2， 300、2. 300、2/ 300  ==> 2,300、2，300、2.300、2/300
            tokens[index] = token + tokens[index + 1]
            del tokens[index + 1]
    return ' '.join(tokens)


def detoken_baifen(text):
    tokens = text.split()
    for index, token in enumerate(tokens):
        if (token.isdigit() or ('.' in token[1:-1] and token.replace('.', '').isdigit())) and \
                tokens[index + 1] == '%':
            # 处理前 1 0 %、10 %、20.34 %  ==>(已变成) 10 %、 20.34 %
            tokens[index] = token + tokens[index + 1]
            del tokens[index + 1]
        if (token.isdigit() and tokens[index + 1][-1] == '%' and tokens[index + 1][:-1].isdigit()) or \
                token[:-1].isdigit() and token[-1] == '.' and tokens[index + 1][:-1].isdigit() and tokens[index + 1][
            -1] == '%':
            # 1 0% ==> 10%、20. 24% ==> 20.24%
            tokens[index] = token + tokens[index + 1]
            del tokens[index + 1]
        if (index + 1 < len(tokens)) and token.isdigit() and tokens[index + 1][0] == '.' and \
                tokens[index + 1][-1] == '%' and tokens[index + 1][1: -1].isdigit():  # 20 .24%  ==> 20.24%
            tokens[index] = token + tokens[index + 1]
            del tokens[index + 1]
        if (index + 2 < len(tokens)) and token.isdigit() and tokens[index + 1] == '.' and \
                tokens[index + 2][:-1].isdigit() and tokens[index + 2][-1] == '%':  # 20 . 24% ==> 20.24%
            tokens[index] = token + tokens[index + 1] + tokens[index + 2]
            del tokens[index + 1]
            del tokens[index + 1]

    return ' '.join(tokens)


def identify_number(token):
    if token.isdigit():
        # 整数
        return True
    elif '.' in token[1: -1] and token.replace('.', '').isdigit():
        # 有小数点的数
        return True
    elif '%' in token[-1] and token.replace('%', '').isdigit():
        # 百分整数
        return True
    elif '%' in token[-1] and '.' in token[1: -2] and re.sub(r'[\.%]', '', token).isdigit():
        # 有小数点的百分数
        return True
    elif ',' in token[1: -1] and token.replace(',', '').isdigit():
        # 英文数字形式
        return True
    elif '，' in token[1: -1] and token.replace('，', '').isdigit():
        # 英文数字形式
        return True
    elif '/' in token[1: -1] and token.replace('/', '').isdigit():
        # 分数 3/4
        return True
    return False


def match_number(text):
    # inputs1, inputs2 = text.split('\t')
    inputs1 = text.split()
    # inputs1, inputs2 = inputs1.split(), inputs2.split()

    ne_digit_order_dict1 = {}
    type = 'NUM'
    # ne_digit_order_dict2 = {}

    for index1, input1 in enumerate(inputs1):
        if identify_number(input1):
            # 若当前token是数字
            ne_digit_order_dict1[type] = ne_digit_order_dict1.get(type, -1) + 1
            inputs1[index1] = '{}|<{}>#{}|{}'.format(input1, type, ne_digit_order_dict1[type], input1)

    # for index2, input2 in enumerate(inputs2):
    #     if identify_number(input2):
    #         ne_digit_order_dict2[type] = ne_digit_order_dict2.get(type, -1) + 1
    #         inputs2[index2] = '<{}>#{}'.format(type, ne_digit_order_dict2[type])

    # return '{}\t{}'.format(' '.join(inputs1), ' '.join(inputs2))
    return ' '.join(inputs1)


# text = '我 在 2000 年 喝 了 23 升 水 ，走 了 3 500 公里 。\t我 在 2000 年 喝 了 23 升 水 ，走 了 3 500 公里 。'
text = '我 在 2 000 年 喝 了 2 . 3% 升 水 ，走 了 3, 500 公里 。'
print(text)
text = detokenize_num(text)
text = detoken_baifen(text)
text = match_number(text)
print(text)
